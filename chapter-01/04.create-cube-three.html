<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>threejs-01</title>
</head>

<body>
    <canvas id="c"></canvas>
</body>
<script type="module">

    // ä¸‰ä¸ªç½‘æ ¼(Mesh)å¼•ç”¨äº†ç›¸åŒçš„ç«‹æ–¹å‡ ä½•ä½“(BoxGeometry)ã€‚æ¯ä¸ªç½‘æ ¼(Mesh)å¼•ç”¨äº†ä¸€ä¸ªå•ç‹¬çš„MeshPhongMaterialæè´¨æ¥æ˜¾ç¤ºä¸åŒçš„é¢œè‰²ã€‚

    import * as THREE from 'https://unpkg.com/three@0.144.0/build/three.module.js';

    function main() {
        const canvas = document.querySelector('#c');
       // 01. åˆ›å»ºæ¸²æŸ“å™¨ 
        // æ¸²æŸ“å™¨è´Ÿè´£å°†ä½ æä¾›çš„æ‰€æœ‰æ•°æ®æ¸²æŸ“ç»˜åˆ¶åˆ°canvasä¸Š 
        // å¦‚æžœä½ æ²¡æœ‰ç»™three.jsä¼ canvasï¼Œthree.jsä¼šè‡ªå·±åˆ›å»ºä¸€ä¸ªã€‚
        // https://threejs.org/docs/#api/en/renderers/WebGLRenderer
        const renderer = new THREE.WebGLRenderer({ 
            canvas,
            antialias: true
        });

        // è®¾ç½®ç”»å¸ƒå¤§å°
        renderer.setSize(window.innerWidth, window.innerHeight)

        
        // 02. åˆ›å»ºç›¸æœº
        // https://threejs.org/manual/#en/fundamentals
        // https://threejs.org/docs/#api/en/cameras/PerspectiveCamera

        // è§†é‡ŽèŒƒå›´(field of view)çš„ç¼©å†™ | æ‘„åƒæœºè§†é”¥ä½“åž‚ç›´è§†é‡Žè§’åº¦
        const fov = 75;
        // ç”»å¸ƒçš„å®½é«˜æ¯”
        const aspect = 2;  // the canvas default
        // è¿‘å¹³é¢
        const near = 0.1;
        // è¿œå¹³é¢
        const far = 5;
        
        // ä½¿ç”¨perspective projectionï¼ˆé€è§†æŠ•å½±ï¼‰æ¥è¿›è¡ŒæŠ•å½±
        // ç”¨æ¥æ¨¡æ‹Ÿäººçœ¼æ‰€çœ‹åˆ°çš„æ™¯è±¡ï¼Œå®ƒæ˜¯3Dåœºæ™¯çš„æ¸²æŸ“ä¸­ä½¿ç”¨å¾—æœ€æ™®éçš„æŠ•å½±æ¨¡å¼ã€‚
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        
        // è®¾ç½®ç›¸æœºä½ç½® | ç›¸æœºçš„ä½ç½®åœ¨z = 2ã€‚å®ƒæœå‘Zè½´è´Ÿæ–¹å‘
        // ç›¸æœºé»˜è®¤å‘ä¸‹çœ‹ -Z è½´ï¼Œå‘ä¸Šçœ‹ +Y è½´
        camera.position.z = 2;


        // 03.åˆ›å»ºåœºæ™¯
        // åœºæ™¯æ˜¯three.jsçš„åŸºæœ¬çš„ç»„æˆéƒ¨åˆ†
        // https://threejs.org/docs/#api/en/scenes/Scene
        const scene = new THREE.Scene();

        {
            const color = 0xFFFFFF;
            const intensity = 1;
            const light = new THREE.DirectionalLight(color, intensity);
            light.position.set(-1, 2, 4);
            scene.add(light);
        }


        // 04. åˆ›å»ºç«‹æ–¹ä½“
        // https://threejs.org/docs/#api/en/geometries/BoxGeometry

        // å®½åº¦;å³å¹³è¡ŒäºŽ X è½´çš„è¾¹çš„é•¿åº¦ã€‚é»˜è®¤å€¼ä¸º 1ã€‚
        const boxWidth = 1;
        // é«˜åº¦;å³å¹³è¡ŒäºŽ Y è½´çš„è¾¹çš„é•¿åº¦ã€‚é»˜è®¤å€¼ä¸º 1ã€‚
        const boxHeight = 1;
        // æ·±åº¦;å³å¹³è¡ŒäºŽ Z è½´çš„è¾¹çš„é•¿åº¦ã€‚é»˜è®¤å€¼ä¸º 1ã€‚
        const boxDepth = 1;

        // ä¼ å…¥å®½åº¦,é«˜åº¦,æ·±åº¦åˆ›å»ºç«‹æ–¹ä½“
        const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

        // ðŸ¦Žå› ä¸ºåŸºç¡€æè´¨ä¸å—å…‰æºå½±å“ | æ‰€ä»¥è¿™é‡Œåšå‡ºè°ƒæ•´æ›´æ”¹ä¸ºå—ç¯å…‰å½±å“çš„ç½‘çº¹ææ–™
        function makeInstance(geometry, color, x) {
            const material = new THREE.MeshPhongMaterial({color});

            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            cube.position.x = x;

            return cube;
        }

        const cubes = [
            makeInstance(geometry, 0x44aa88,  0),
            makeInstance(geometry, 0x8844aa, -2),
            makeInstance(geometry, 0xaa8844,  2),
        ];

        // å› ä¸ºæˆ‘ä»¬ç›´è§†-Zè½´å¹¶ä¸”ç«‹æ–¹ä½“å’Œåæ ‡è½´æ˜¯å¯¹é½çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬åªèƒ½çœ‹åˆ°ä¸€ä¸ªé¢,åœ¨è§†è§‰æ•ˆæžœä¸Šå¹¶ä¸èƒ½çœ‹å‡ºè¿™æ˜¯ä¸€ä¸ªç«‹æ–¹ä½“ã€‚
        // æˆ‘ä»¬æ¥è®©ç«‹æ–¹ä½“æ—‹è½¬èµ·æ¥ï¼Œä»¥ä¾¿æ›´å¥½çš„åœ¨ä¸‰ç»´çŽ¯å¢ƒä¸­æ˜¾ç¤ºã€‚
        // ä¸ºäº†è®©å®ƒåŠ¨èµ·æ¥æˆ‘ä»¬éœ€è¦ç”¨åˆ°ä¸€ä¸ªæ¸²æŸ“å¾ªçŽ¯å‡½æ•° requestAnimationFrame.
        // https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame
        function render(time) {
            // console.log(time);
            time *= 0.001;  // æ—¶é—´å•ä½è½¬ä¸ºç§’

            cubes.forEach((cube, ndx) => {
                const speed = 1 + ndx * .1;
                const rot = time * speed;
                cube.rotation.x = rot;
                cube.rotation.y = rot;
            });

            renderer.render(scene, camera);

            requestAnimationFrame(render);
        }

        // 07. è°ƒç”¨requestAnimationFrame
        requestAnimationFrame(render);

    }

    main();

</script>

</html>